类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

![](http://olax25rea.bkt.clouddn.com/331425-20160621125941772-1913742708.png)

### 预加载
类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。

### 类的生命周期
![](http://olax25rea.bkt.clouddn.com/331425-20160621125943209-1443333281.png)

* 加载
 查找并加载类的二进制数据
 加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：
    1、通过一个类的全限定名来获取其定义的二进制字节流。
    2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。
    相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

   加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。

* 连接   
  1.验证:确保被加载的类的正确性
  2.准备:为类的静态变量分配内存，并将其初始化为默认值
 
   准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

    1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。

    2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
    
    > 这里还需要注意如下几点：
      对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
      对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
      对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
     如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。
  
    3、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。


* 解析
  
  解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。

  直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
  
  初始化
  
   初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：
   ①声明类变量是指定初始值
   ②使用静态代码块为类变量指定初始值
   JVM初始化步骤
   1、假如这个类还没有被加载和连接，则程序先加载并连接该类
   2、假如该类的直接父类还没有被初始化，则先初始化其直接父类
   3、假如类中有初始化语句，则系统依次执行这些初始化语句
   类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：
   – 创建类的实例，也就是new的方式
   – 访问某个类或接口的静态变量，或者对该静态变量赋值
   – 调用类的静态方法
   – 反射（如Class.forName(“com.shengsiyuan.Test”)）
   – 初始化某个类的子类，则其父类也会被初始化
   – Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类
   结束生命周期
   •在如下几种情况下，Java虚拟机将结束生命周期
   – 执行了System.exit()方法
   – 程序正常执行结束
   – 程序在执行过程中遇到了异常或错误而异常终止
   – 由于操作系统出现错误而导致Java虚拟机进程终止 

### JVM类加载机制
 
 * 全盘负责
 当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
 * 父类委托
 先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
 * 缓存机制
 缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效

### 类的加载器
 * 寻找加载器 
 * 启动加载器  Bootstrap ClassLoader
 * 扩展加载器  Extension ClassLoader
 * 应用程序加载器 Application ClassLoader
 
   应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：
   1）在执行非置信代码之前，自动验证数字签名。
   2）动态地创建符合用户特定需要的定制化构建类。
   3）从特定的场所取得java class，例如数据库中和网络中。



### 类的加载
   类加载有三种方式：
   1、命令行启动应用时候由JVM初始化加载
   2、通过Class.forName()方法动态加载
   3、通过ClassLoader.loadClass()方法动态加载
   
  > Class.forName()和ClassLoader.loadClass()区别
    Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；
    ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。

### 双亲委派机制
   
   双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。
 
   1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 
   2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
   3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；
   4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

   * 系统类防止内存中出现多份同样的字节码
   * 保证Java程序安全稳定运行

### 自定义类加载器