###内存模型
临时数据存放在主存(物理内存)中，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。
也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中

一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。
解决方案  
 1.通过在总线加LOCK#锁的方式
 2.通过缓存一致性协议
 
> MESI是一种主流的缓存一致性协议，已经用在Pentium和PowerPC处理器中。它定义了缓存块的几种状态
   modified（修改）：缓存块已经被修改，必须被写回主存，其他处理器不能再缓存这个块
   exclusive（互斥）：缓存块还没有被修改，且其他处理器不能装入这个缓存块
   share（共享）：缓存块未被修改，且其他处理器可以装入这个缓存块
   invalid（无效）：缓存块中的数据无效

###并发编程
* 原子性
一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
* 可见性  volatie
可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值

> volatie怎么保证可见性
  
* 有序性
即程序执行的顺序按照代码的先后顺序执行